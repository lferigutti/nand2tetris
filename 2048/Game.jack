/**
 * Game is in charge of call the logic of the game, and hande end of the game and workflows.
 */

class Game {
  field Board board; // Board of the game itself
  field int size; // Size of the board. Hardcoded by now
  field int initScreenRow, initScreenCol; // Initical position of the board in the screen
  field Array cellStrings; // Pre-built strings for drawing cells
  field String winMessage, loseMessage; // Cached status messages
  field String bannerDecoration, footerDecoration; // Cached decorative strings

  constructor Game new() {
    let size = 4;
    let board = Board.new(size);
    let initScreenRow = 6;
    let initScreenCol = 20;
    do initCellStrings();
    do initStatusMessages();
    do initDecorationStrings();
    return this;
  }

  /* Pre-build all strings needed to render the cells to avoid runtime allocations */
  method void initCellStrings() {
    let cellStrings = Array.new(15);

    let cellStrings[0] = createCellString(32, 32, 32, 32, 32); // empty
    let cellStrings[1] = createCellString(32, 32, 50, 32, 32); // 2
    let cellStrings[2] = createCellString(32, 32, 52, 32, 32); // 4
    let cellStrings[3] = createCellString(32, 32, 56, 32, 32); // 8
    let cellStrings[4] = createCellString(32, 49, 54, 32, 32); // 16
    let cellStrings[5] = createCellString(32, 51, 50, 32, 32); // 32
    let cellStrings[6] = createCellString(32, 54, 52, 32, 32); // 64
    let cellStrings[7] = createCellString(32, 49, 50, 56, 32); // 128
    let cellStrings[8] = createCellString(32, 50, 53, 54, 32); // 256
    let cellStrings[9] = createCellString(32, 53, 49, 50, 32); // 512
    let cellStrings[10] = createCellString(49, 48, 50, 52, 32); // 1024
    let cellStrings[11] = createCellString(50, 48, 52, 56, 32); // 2048
    let cellStrings[12] = createCellString(52, 48, 57, 54, 32); // 4096
    let cellStrings[13] = createCellString(56, 49, 57, 50, 32); // 8192 Just for fall back future games
    let cellStrings[14] = createCellString(32, 69, 82, 82, 32); // ERR
    return;
  }

  method String createCellString(int c1, int c2, int c3, int c4, int c5) {
    var String s;
    let s = String.new(5);
    do s.appendChar(c1);
    do s.appendChar(c2);
    do s.appendChar(c3);
    do s.appendChar(c4);
    do s.appendChar(c5);
    return s;
  }

  /* Here is the logic of the game */
  method void run() {
    var char key;
    var boolean exit, moved;
    
    let key = 0;
    
    do board.addRandomTile();
    do board.addRandomTile();
    do draw();
    
    let exit = false;
    
    while (~exit) {

      while (key = 0) {
        let key = Keyboard.keyPressed();
      }
   
      let moved = handleMove(key); 

      if (moved) {
        do board.addRandomTile();
        do draw();
      }

      if (board.hasValue(2048)) {
        do showStatus(winMessage);
        let exit = true;
      } else {
        if (~board.hasMoves()) {
          do showStatus(loseMessage);
          let exit = true;
        }
      }

      if (key = 140) { // ESC key
        let exit = true;
      }
      
      while (~(key = 0)) {
        let key = Keyboard.keyPressed();
      }
    }
    
    return;
  }

  /* Handle a move based on key pressed. Returns true if board changed. */
  method boolean handleMove(char key) {
    var boolean moved;
    
    let moved = false;
    
    if (key = 130) { // Left arrow
      let moved = board.moveLeft();
    }
    if (key = 131) { // Up arrow
      let moved = board.moveUp();
    }
    if (key = 132) { // Right arrow
      let moved = board.moveRight();
    }
    if (key = 133) { // Down arrow
      let moved = board.moveDown();
    }
    
    return moved;
  }


  /* This method is in charge of undestanding where to draw and what to draw. */
  method void draw() {
    var int rowIndex;
    var int screenRow, screenCol;
    
    let rowIndex = 0;
    let screenRow = initScreenRow;
    let screenCol = initScreenCol;

    do drawDecorations();

    while (rowIndex < size) {
      do drawHorizontalBorder(screenRow, screenCol);
      let screenRow = screenRow + 1;
      do drawRow(rowIndex, screenRow, screenCol);
      let rowIndex = rowIndex + 1;
      let screenRow = screenRow + 1;
    }
    
    // Draw last line
    do drawHorizontalBorder(screenRow, screenCol);
    return;
  }

  /* Draw some random decorations, to do it nicer */
  method void drawDecorations() {
    var int bannerRow, footerRow, boardWidth, bannerLen, footerLen, bannerCol, footerCol;
    let boardWidth = Math.multiply(size, 6);
    let boardWidth = boardWidth + 1;
    let bannerLen = bannerDecoration.length();
    let footerLen = footerDecoration.length();
    let bannerRow = initScreenRow - 3;
    if (bannerRow < 0) {
      let bannerRow = 0;
    }
    let footerRow = Math.multiply(size, 2);
    let footerRow = footerRow + initScreenRow;
    let footerRow = footerRow + 2;

    let bannerCol = boardWidth - bannerLen;
    if (bannerCol < 0) {
      let bannerCol = 0;
    } else {
      let bannerCol = bannerCol / 2;
    }
    let bannerCol = bannerCol + initScreenCol;

    let footerCol = boardWidth - footerLen;
    if (footerCol < 0) {
      let footerCol = 0;
    } else {
      let footerCol = footerCol / 2;
    }
    let footerCol = footerCol + initScreenCol;

    do Output.moveCursor(bannerRow, bannerCol);
    do Output.printString(bannerDecoration);
    do Output.moveCursor(footerRow, footerCol);
    do Output.printString(footerDecoration);
    return;
  }

  /* This avoid a memory using sting literals. It is a same approach like the numbers*/
  method void drawHorizontalBorder(int screenRow, int screenCol) {
    var int col, dashCount;
    do Output.moveCursor(screenRow, screenCol);
    let col = 0;
    while (col < size) {
      do Output.printChar(43); // '+'
      let dashCount = 0;
      while (dashCount < 5) {
        do Output.printChar(45); // '-'
        let dashCount = dashCount + 1;
      }
      let col = col + 1;
    }
    do Output.printChar(43);
    return;
  }

  /* This method draws only one row */
  method void drawRow(int rowIndex, int screenRow, int screenCol) {
    var int col, value;

    do Output.moveCursor(screenRow, screenCol);
    do Output.printChar(124); // '|'
    let col = 0;
    while (col < size) {
      let value = board.get(rowIndex, col);
      do Output.printString(getCellString(value));
      do Output.printChar(124);
      
      let col = col + 1;
    }
    return;
  }

  method void clearStatusLine() {
    var int row, width, i;
    let row = Math.multiply(size, 2);
    let row = row + initScreenRow;
    let row = row + 3;
    let width = Math.multiply(size, 6);
    let width = width + 1;
    do Output.moveCursor(row, initScreenCol);
    let i = 0;
    while (i < width) {
      do Output.printChar(32);
      let i = i + 1;
    }
    do Output.moveCursor(row, initScreenCol);
    return;
  }

  method void showStatus(String message) {
    do clearStatusLine();
    do Output.printString(message);
    return;
  }

  method void initDecorationStrings() {
    var String message;
    let message = String.new(15);
    do message.appendChar(61); // =
    do message.appendChar(61);
    do message.appendChar(32); // space
    do message.appendChar(74); // J
    do message.appendChar(65); // A
    do message.appendChar(67); // C
    do message.appendChar(75); // K
    do message.appendChar(32);
    do message.appendChar(50); // 2
    do message.appendChar(48); // 0
    do message.appendChar(52); // 4
    do message.appendChar(56); // 8
    do message.appendChar(32);
    do message.appendChar(61);
    do message.appendChar(61);
    let bannerDecoration = message;

    let message = String.new(24);
    do message.appendChar(85); // U
    do message.appendChar(115); // s
    do message.appendChar(101); // e
    do message.appendChar(32);
    do message.appendChar(97); // a
    do message.appendChar(114); // r
    do message.appendChar(114); // r
    do message.appendChar(111); // o
    do message.appendChar(119); // w
    do message.appendChar(115); // s
    do message.appendChar(32);
    do message.appendChar(116); // t
    do message.appendChar(111); // o
    do message.appendChar(32);
    do message.appendChar(114); // r
    do message.appendChar(101); // e
    do message.appendChar(97); // a
    do message.appendChar(99); // c
    do message.appendChar(104); // h
    do message.appendChar(32);
    do message.appendChar(50); // 2
    do message.appendChar(48); // 0
    do message.appendChar(52); // 4
    do message.appendChar(56); // 8
    let footerDecoration = message;
    return;
  }


  /* Returs a tile from a value -> it is tedius but follows the limitaiton of jack language */
  method String getCellString(int value) {

    if (value = 0) {
      return cellStrings[0];
    }
    if (value = 2) {
      return cellStrings[1];
    }
    if (value = 4) {
      return cellStrings[2];
    }
    if (value = 8) {
      return cellStrings[3];
    }
    if (value = 16) {
      return cellStrings[4];
    }
    if (value = 32) {
      return cellStrings[5];
    }
    if (value = 64) {
      return cellStrings[6];
    }
    if (value = 128) {
      return cellStrings[7];
    }
    if (value = 256) {
      return cellStrings[8];
    }  
    if (value = 512) {
      return cellStrings[9];
    }
    if (value = 1024) {
      return cellStrings[10];
    }  
    if (value = 2048) {
      return cellStrings[11];
    }
    if (value = 4096) {
      return cellStrings[12];
    }
    if (value = 8192) {
      return cellStrings[13];
    }
    // For any other value, return ERR to indicate overflow
    return cellStrings[14];
  }

  /** Disposes this game */
  method void dispose() {
    do disposeCellStrings();
    do disposeStatusMessages();
    do disposeDecorationStrings();
    do board.dispose();
    do Memory.deAlloc(this);
    return;
  }

  method void disposeCellStrings() {
    var int i;
    var String cellStr;
    let i = 0;
    while (i < 15) {
      let cellStr = cellStrings[i];
      do cellStr.dispose();
      let i = i + 1;
    }
    do Memory.deAlloc(cellStrings);
    return;
  }

  method void disposeStatusMessages() {
    do winMessage.dispose();
    do loseMessage.dispose();
    return;
  }

  method void disposeDecorationStrings() {
    do bannerDecoration.dispose();
    do footerDecoration.dispose();
    return;
  }

  method void initStatusMessages() {
    var String message;
    let message = String.new(18);
    do message.appendChar(89); // Y
    do message.appendChar(79); // O
    do message.appendChar(85); // U
    do message.appendChar(32); // space
    do message.appendChar(87); // W
    do message.appendChar(73); // I
    do message.appendChar(78); // N
    do message.appendChar(33); // !
    do message.appendChar(32); // space
    do message.appendChar(80); // P
    do message.appendChar(82); // R
    do message.appendChar(69); // E
    do message.appendChar(83); // S
    do message.appendChar(83); // S
    do message.appendChar(32); // space
    do message.appendChar(69); // E
    do message.appendChar(83); // S
    do message.appendChar(67); // C
    let winMessage = message;

    let message = String.new(25);
    do message.appendChar(78); // N
    do message.appendChar(79); // O
    do message.appendChar(32); // space
    do message.appendChar(77); // M
    do message.appendChar(79); // O
    do message.appendChar(86); // V
    do message.appendChar(69); // E
    do message.appendChar(83); // S
    do message.appendChar(32); // space
    do message.appendChar(76); // L
    do message.appendChar(69); // E
    do message.appendChar(70); // F
    do message.appendChar(84); // T
    do message.appendChar(32); // space
    do message.appendChar(45); // -
    do message.appendChar(32); // space
    do message.appendChar(89); // Y
    do message.appendChar(79); // O
    do message.appendChar(85); // U
    do message.appendChar(32); // space
    do message.appendChar(76); // L
    do message.appendChar(79); // O
    do message.appendChar(83); // S
    do message.appendChar(69); // E
    do message.appendChar(33); // !
    let loseMessage = message;
    return;
  }

}


